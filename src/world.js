import { Model } from './model.js';

export class World {
  constructor({ atoms, relations, invariants, observers }, _events=[], _parent) {
    this._atoms = atoms;
    this._relations = relations;
    this._invariants = invariants;
    this._observers = observers;

    if (_parent) {
      this._parent = _parent;
      this._model = null;
    } else {
      this._model = new Model({
        atoms: atoms,
        relations: relations,
        invariants: invariants
      })
      this._model.freeze();
    }
    this._observers = observers;
    this._events = _events;
  }

  check(relationName, ...atoms) {
    if (!this._model) {
      this._model = this._parent._model;
    }
    this._applyEvents();
    return this._model.check(relationName, ...atoms);
  }

  _applyEvents(triggeredObservers=new Set()) {
    if (this._parent) {
      this._parent._applyEvents();
    }
    if (!this._model) {
      this._model = this._parent._model;
    }

    let nextEvents = []; // queue of events generated by observers
    if (this._model.frozen) {
      this._model = this._model.clone();
    }

    this._events.forEach((event) => {
      let observerOldValues = this._observers.map((o) => o.check(this._model));
      this._model.assert(event);
      let observerEffects = this._observers.map((o, i) => {
        let effect = o.consider(this._model, observerOldValues[i]);
        if (effect && triggeredObservers.has(o)) {
          throw "Observer triggered twice!";
        } else if (effect) {
          debugger
          triggeredObservers.add(o);
          nextEvents = nextEvents.concat(effect.events);
        }
      });
    });

    this._events = nextEvents;
    if (nextEvents.length == 0) {
      this._model.freeze();
    } else {
      this._applyEvents(triggeredObservers);
    }
  }

  event(event) {
    return new World({
      atoms: this._atoms,
      relations: this._relations,
      invariants: this._invariants,
      observers: this._observers
    }, [event], this);
  }
}
