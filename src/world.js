import { Model } from './model.js';
import { Uid } from './uid.js';

export class World {
  constructor({
    atoms,
    relations,
    derivedRelations,
    invariants,
    observers,
    transitors,
    init
  }, _events=[], _parent) {
    this._uid = Uid.next();
    this._atoms = atoms;
    this._relations = relations;
    this._derivedRelations = derivedRelations;
    this._invariants = invariants;
    this._observers = observers;
    this._transitors = transitors;

    if (_parent) {
      this._parent = _parent;
      this._model = null;
    } else {
      this._model = new Model({
        atoms: atoms,
        relations: relations,
        derivedRelations: derivedRelations || [],
        invariants: invariants
      })
      this._model.freeze();
    }

    if (init && _events && _events.length > 0) {
      throw "Constructor accepts at most one of `init` and `_events`";
    }
    if (init) {
      this._events = [init];
    } else {
      this._events = _events;
    }
  }

  // accessor methods
  get uid() { return this._uid; }
  // end accessor methods

  validateAction(action) {
    let permitted = true;
    let messages = [];
    this._transitors.forEach((transitor) => {
      let result = transitor.test(action, this)
      permitted &= result[0];
      messages.push(result[1]);
    });
    return [permitted, messages];
  }

  applyAction(action) {
    let validationResult = this.validateAction(action);
    let permitted = validationResult[0];
    let messages = validationResult[1];
    if (!permitted) {
      action.fail(this, messages);
      return this;
    } else {
      let nextWorld = this.event(action.event);
      action.succeed(nextWorld);
      return nextWorld;
    }
  }

  check(relationName, atoms) {
    this._prepareModel();
    return this._model.check(relationName, atoms);
  }

  which(relationName, subject) {
    this._prepareModel();
    return this._model.which(relationName, subject);
  }

  firstWhich(relationName, subject) {
    this._prepareModel();
    return this._model.firstWhich(relationName, subject);
  }

  subjects(relationName, subject) {
    this._prepareModel();
    return this._model.subjects(relationName, subject);
  }

  query({ and, or, not, which, firstWhich, check, subjects }) {
    this._prepareModel();
    return this._model.query(arguments[0]);
  }

  _prepareModel() {
    if (!this._model) {
      this._model = this._parent._model;
    }
    this._applyEvents();
  }

  _applyEvents(triggeredObservers=new Set()) {
    if (this._parent) {
      this._parent._applyEvents();
    }
    if (!this._model) {
      this._model = this._parent._model;
    }
    if (this._events.length == 0) {
      return;
    }
    if (this._model.frozen) {
      this._model = this._model.clone();
    }

    // todo: feels like some of this logic should be pushed down into Observer
    let nextEvents = []; // queue of events generated by observers
    this._events.forEach((event) => {
      let observerOldValues = this._observers.map((o) => o.examine(this._model));

      this._model.assert(event);
      let observerEffects = this._observers.map((o, i) => {
        let effect = o.consider(this._model, observerOldValues[i]);
        if (effect && triggeredObservers.has(o)) {
          throw "Observer triggered twice!";
        } else if (effect) {
          triggeredObservers.add(o);
          nextEvents = nextEvents.concat(effect.events);
        }
      });
    });

    this._events = nextEvents;
    if (nextEvents.length == 0) {
      this._model.freeze();
    } else {
      this._applyEvents(triggeredObservers);
    }
  }

  event(event) {
    return new World({
      atoms: this._atoms,
      relations: this._relations,
      invariants: this._invariants,
      observers: this._observers,
      transitors: this._transitors
    }, [event], this);
  }
}
