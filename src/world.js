import { Model } from './model.js';
import { Uid } from './uid.js';

export class World {
  constructor({
    atoms,
    relations,
    derivedRelations,
    invariants,
    observers,
    transitors,
    actionGenerators,
    conceptTable,
    init
  }, _events=[], _parent, _lastAction) {
    this._uid = Uid.next();
    this._atoms = atoms;
    this._relations = relations;
    this._derivedRelations = derivedRelations;
    this._invariants = invariants;
    this._observers = observers;
    this._transitors = transitors;
    this._actionGenerators = actionGenerators;
    this._conceptTable = conceptTable;
    this._lastAction = _lastAction;

    this._hasGeneratedNext = false;

    if (_parent) {
      this._parent = _parent;
      this._model = null;
    } else {
      this._model = new Model({
        atoms: atoms,
        relations: relations,
        derivedRelations: derivedRelations || [],
        invariants: invariants
      })
      this._model.freeze();
    }

    if (init && _events && _events.length > 0) {
      throw "Constructor accepts at most one of `init` and `_events`";
    }
    if (init) {
      this._events = [init];
    } else {
      this._events = _events;
    }
  }

  // accessor methods
  get uid() { return this._uid; }
  get lastAction() { return this._lastAction; }
  // end accessor methods

  getConcept(atom) {
    return this._conceptTable.get(atom);
  }

  validateAction(action) {
    let permitted = true;
    let messages = [];
    this._transitors.forEach((transitor) => {
      let result = transitor.test(action, this)
      permitted &= result[0];
      messages.push(result[1]);
    });
    return [permitted, messages];
  }

  applyAction(action) {
    let validationResult = this.validateAction(action);
    let permitted = validationResult[0];
    let messages = validationResult[1];
    if (!permitted && !action.failed) {
      action.fail(messages);
    }
    if (!action.failed) {
      const nextWorld = this.next([action.event], { lastAction: action });
      action.succeed(nextWorld);
      return nextWorld;
    } else {
      return this.next([], { lastAction: action });
    }
  }

  generateActions() {
    return this._actionGenerators.map((ag) => {
      return ag.getActions(this);
    }).flat();
  }

  check(relationName, atoms) {
    this._prepareModel();
    return this._model.check(relationName, atoms);
  }

  which(relationName, subject) {
    this._prepareModel();
    return this._model.which(relationName, subject);
  }

  firstWhich(relationName, subject) {
    this._prepareModel();
    return this._model.firstWhich(relationName, subject);
  }

  anyWhich(relationName, subjects) {
    this._prepareModel();
    return this._model.anyWhich(relationName, subjects);
  }

  subjects(relationName, subject) {
    this._prepareModel();
    return this._model.subjects(relationName, subject);
  }

  query({ and, or, not, which, firstWhich, check, subjects }) {
    this._prepareModel();
    return this._model.query(arguments[0]);
  }

  state(concept, stateField) {
    this._prepareModel(); // needed?
    return this._conceptTable.get(concept).getState(this, stateField);
  }

  queryFn() {
    return this.query.bind(this);
  }

  stateFn() {
    return this.state.bind(this);
  }

  _prepareModel() {
    this._applyEvents();
  }

  _applyEvents(triggeredObservers=new Set()) {
    if (this._parent) {
      this._parent._applyEvents();
    }
    if (!this._model) {
      this._model = Model.fromParent(this._parent._model)
    }
    if (this._events.length == 0) {
      return;
    }
    if (this._model.frozen) {
      this._model = this._model.clone();
    }

    // todo: feels like some of this logic should be pushed down into Observer
    let nextEvents = []; // queue of events generated by observers
    this._events.forEach((event) => {
      let observerOldValues = this._observers.map((o) => o.examine(this._model));

      this._model.assert(event);

      let observerEffects = this._observers.map((o, i) => {
        let effect = o.consider(this._model, observerOldValues[i]);
        if (effect && triggeredObservers.has(o)) {
          throw 'Observer triggered twice!';
        } else if (effect) {
          triggeredObservers.add(o);
          nextEvents = nextEvents.concat(effect.events);
        }
      });
    });

    this._events = nextEvents;
    if (nextEvents.length == 0) {
      this._model.freeze();
    } else if (triggeredObservers.size > 0) {
      this._applyEvents(triggeredObservers);
    }
  }

  commitState() {
    if (this._conceptTable) {
      for (let concept of this._conceptTable.values()) {
        if (concept.hasState) {
          concept.commitWorld(this);
        }
      }
    }
  }

  next(events, { lastAction }={}) {
    if (this._hasGeneratedNext) {
      throw "Can't call `next` more than once on the same world!";
    }
    this._hasGeneratedNext = true;

    return new World({
      atoms: this._atoms,
      relations: this._relations,
      invariants: this._invariants,
      observers: this._observers,
      transitors: this._transitors,
      actionGenerators: this._actionGenerators,
      conceptTable: this._conceptTable
    }, events, this, lastAction);
  }
}
